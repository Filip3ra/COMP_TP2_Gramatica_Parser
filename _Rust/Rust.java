/* Generated By:JavaCC: Do not edit this line. Rust.java */
import java.io.*;
class Rust implements RustConstants {
        public static void main( String[] args )throws ParseException, Exception
        {
                Rust lex = new Rust(new FileInputStream(args[0]));
                lex.AnaliseLexica();
        }

  static final public void AnaliseLexica() throws ParseException {
 Token t;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_AS:
      case KW_BREAK:
      case KW_CONST:
      case KW_CONTINUE:
      case KW_CRATE:
      case KW_ELSE:
      case KW_ENUM:
      case KW_EXTERN:
      case KW_FALSE:
      case KW_FN:
      case KW_FOR:
      case KW_IF:
      case KW_IMPL:
      case KW_IN:
      case KW_LET:
      case KW_LOOP:
      case KW_MATCH:
      case KW_MOD:
      case KW_MOVE:
      case KW_MUT:
      case KW_PUB:
      case KW_REF:
      case KW_RETURN:
      case KW_SELFVALUE:
      case KW_SELFTYPE:
      case KW_STATIC:
      case KW_STRUCT:
      case KW_SUPER:
      case KW_TRAIT:
      case KW_TRUE:
      case KW_TYPE:
      case KW_UNSAFE:
      case KW_USE:
      case KW_WHERE:
      case KW_WHILE:
      case KW_ASYNC:
      case KW_AWAIT:
      case KW_DYN:
      case KW_ABSTRACT:
      case KW_BECOME:
      case KW_BOX:
      case KW_DO:
      case KW_FINAL:
      case KW_MACRO:
      case KW_OVERRIDE:
      case KW_PRIV:
      case KW_TYPEOF:
      case KW_UNSIZED:
      case KW_VIRTUAL:
      case KW_YIELD:
      case KW_TRY:
      case BOOLEANO:
      case KW_UNION:
      case KW_STATICLIFETIME:
      case MACRO:
      case APAREN:
      case FPAREN:
      case ACHAVES:
      case FCHAVES:
      case ACOLCHETE:
      case FCOLCHETE:
      case MAIS:
      case MENOS:
      case ESTRELA:
      case BARRAINVERTIDA:
      case PORCENTO:
      case CHAPEU:
      case EXCLAMACAO:
      case ECOMERCIAL:
      case OU:
      case ANDAND:
      case OUOU:
      case MENORMENOR:
      case MAIORMAIOR:
      case MAISIGUAL:
      case MENOSIGUAL:
      case ESTRELAIGUAL:
      case CONTRABARRAIGUAL:
      case PORCENTOIGUAL:
      case CHAPEUIGUAL:
      case ECOMERCIALIGUAL:
      case OUIGUAL:
      case MENORMENORIGUAL:
      case MAIORMAIORIGUAL:
      case IGUAL:
      case IGUALIGUAL:
      case DIFERENTE:
      case MAIORQUE:
      case MENORQUE:
      case MAIOROUIGUAL:
      case MENOROUIGUAL:
      case ARROBA:
      case UNDERLINE:
      case PONTO:
      case PONTOPONTO:
      case PONTOPONTOPONTO:
      case PONTOPONTOIGUAL:
      case VIRGULA:
      case PONTOVIRGULA:
      case DOISPONTOS:
      case DUPLODOISPONTOS:
      case SETA:
      case SETAGORDA:
      case QUADRADO:
      case CIFRAO:
      case ASPASDUPLAS:
      case ASPASSIMPLES:
      case INTERROGACAO:
      case NUM:
      case FLOAT:
      case CADEIA:
      case CARACTERE:
      case ID:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_AS:
        jj_consume_token(KW_AS);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: as");
        break;
      case KW_BREAK:
        jj_consume_token(KW_BREAK);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: break");
        break;
      case KW_CONST:
        jj_consume_token(KW_CONST);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: const");
        break;
      case KW_CONTINUE:
        jj_consume_token(KW_CONTINUE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: continue");
        break;
      case KW_CRATE:
        jj_consume_token(KW_CRATE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: crate");
        break;
      case KW_ELSE:
        jj_consume_token(KW_ELSE);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: else");
        break;
      case KW_ENUM:
        jj_consume_token(KW_ENUM);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: enum");
        break;
      case KW_EXTERN:
        jj_consume_token(KW_EXTERN);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: extern");
        break;
      case KW_FALSE:
        jj_consume_token(KW_FALSE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: false");
        break;
      case KW_FN:
        jj_consume_token(KW_FN);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: fn");
        break;
      case KW_FOR:
        jj_consume_token(KW_FOR);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: for");
        break;
      case KW_IF:
        jj_consume_token(KW_IF);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: if");
        break;
      case KW_IMPL:
        jj_consume_token(KW_IMPL);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: impl");
        break;
      case KW_IN:
        jj_consume_token(KW_IN);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: in");
        break;
      case KW_LET:
        jj_consume_token(KW_LET);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: let");
        break;
      case KW_LOOP:
        jj_consume_token(KW_LOOP);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: loop");
        break;
      case KW_MATCH:
        jj_consume_token(KW_MATCH);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: match");
        break;
      case KW_MOD:
        jj_consume_token(KW_MOD);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: mod");
        break;
      case KW_MOVE:
        jj_consume_token(KW_MOVE);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: move");
        break;
      case KW_MUT:
        jj_consume_token(KW_MUT);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: mut");
        break;
      case KW_PUB:
        jj_consume_token(KW_PUB);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: pub");
        break;
      case KW_REF:
        jj_consume_token(KW_REF);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: ref");
        break;
      case KW_RETURN:
        jj_consume_token(KW_RETURN);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: return");
        break;
      case KW_SELFVALUE:
        jj_consume_token(KW_SELFVALUE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: self");
        break;
      case KW_SELFTYPE:
        jj_consume_token(KW_SELFTYPE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: Self");
        break;
      case KW_STATIC:
        jj_consume_token(KW_STATIC);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: static");
        break;
      case KW_STRUCT:
        jj_consume_token(KW_STRUCT);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: struct");
        break;
      case KW_SUPER:
        jj_consume_token(KW_SUPER);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: super");
        break;
      case KW_TRAIT:
        jj_consume_token(KW_TRAIT);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: trait");
        break;
      case KW_TRUE:
        jj_consume_token(KW_TRUE);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: true");
        break;
      case KW_TYPE:
        jj_consume_token(KW_TYPE);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: type");
        break;
      case KW_UNSAFE:
        jj_consume_token(KW_UNSAFE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: unsafe");
        break;
      case KW_USE:
        jj_consume_token(KW_USE);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: use");
        break;
      case KW_WHERE:
        jj_consume_token(KW_WHERE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: where");
        break;
      case KW_WHILE:
        jj_consume_token(KW_WHILE);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: while");
        break;
      case KW_ASYNC:
        jj_consume_token(KW_ASYNC);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: async");
        break;
      case KW_AWAIT:
        jj_consume_token(KW_AWAIT);
                                         System.out.println("PALAVRAS RESERVADAS STRICT: await");
        break;
      case KW_DYN:
        jj_consume_token(KW_DYN);
                                                 System.out.println("PALAVRAS RESERVADAS STRICT: dyn");
        break;
      case KW_ABSTRACT:
        jj_consume_token(KW_ABSTRACT);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: abstract");
        break;
      case KW_BECOME:
        jj_consume_token(KW_BECOME);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: become");
        break;
      case KW_BOX:
        jj_consume_token(KW_BOX);
                                                 System.out.println("PALAVRAS RESERVADAS RESERVED: box");
        break;
      case KW_DO:
        jj_consume_token(KW_DO);
                                                 System.out.println("PALAVRAS RESERVADAS RESERVED: do");
        break;
      case KW_FINAL:
        jj_consume_token(KW_FINAL);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: final");
        break;
      case KW_MACRO:
        jj_consume_token(KW_MACRO);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: macro");
        break;
      case KW_OVERRIDE:
        jj_consume_token(KW_OVERRIDE);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: override");
        break;
      case KW_PRIV:
        jj_consume_token(KW_PRIV);
                                                 System.out.println("PALAVRAS RESERVADAS RESERVED: priv");
        break;
      case KW_TYPEOF:
        jj_consume_token(KW_TYPEOF);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: typeof");
        break;
      case KW_UNSIZED:
        jj_consume_token(KW_UNSIZED);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: unsized");
        break;
      case KW_VIRTUAL:
        jj_consume_token(KW_VIRTUAL);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: virtual");
        break;
      case KW_YIELD:
        jj_consume_token(KW_YIELD);
                                         System.out.println("PALAVRAS RESERVADAS RESERVED: yield");
        break;
      case KW_TRY:
        jj_consume_token(KW_TRY);
                                                 System.out.println("PALAVRAS RESERVADAS RESERVED: try");
        break;
      case KW_UNION:
        jj_consume_token(KW_UNION);
                                         System.out.println("PALAVRAS RESERVADAS WEAK: union");
        break;
      case KW_STATICLIFETIME:
        jj_consume_token(KW_STATICLIFETIME);
                                      System.out.println("PALAVRAS RESERVADAS WEAK: 'static");
        break;
      case MAIS:
        jj_consume_token(MAIS);
                                                 System.out.println("MAIS +");
        break;
      case MENOS:
        jj_consume_token(MENOS);
                                                 System.out.println("MENOS -");
        break;
      case ESTRELA:
        jj_consume_token(ESTRELA);
                                                 System.out.println("ESTRELA *");
        break;
      case BARRAINVERTIDA:
        jj_consume_token(BARRAINVERTIDA);
                                         System.out.println("BARRAINVERTIDA /");
        break;
      case PORCENTO:
        jj_consume_token(PORCENTO);
                                         System.out.println("PORCENTO %");
        break;
      case CHAPEU:
        jj_consume_token(CHAPEU);
                                                 System.out.println("CHAPEU ^");
        break;
      case EXCLAMACAO:
        jj_consume_token(EXCLAMACAO);
                                         System.out.println("EXCLAMACAO !");
        break;
      case ECOMERCIAL:
        jj_consume_token(ECOMERCIAL);
                                         System.out.println("ECOMERCIAL &");
        break;
      case OU:
        jj_consume_token(OU);
                                                 System.out.println("OU |");
        break;
      case ANDAND:
        jj_consume_token(ANDAND);
                                                 System.out.println("ANDAND &&");
        break;
      case OUOU:
        jj_consume_token(OUOU);
                                                 System.out.println("OUOU ||");
        break;
      case MENORMENOR:
        jj_consume_token(MENORMENOR);
                                         System.out.println("PONTUACAO: <<");
        break;
      case MAIORMAIOR:
        jj_consume_token(MAIORMAIOR);
                                         System.out.println("PONTUACAO: >>");
        break;
      case MAISIGUAL:
        jj_consume_token(MAISIGUAL);
                                         System.out.println("PONTUACAO: +=");
        break;
      case MENOSIGUAL:
        jj_consume_token(MENOSIGUAL);
                                         System.out.println("PONTUACAO: -=");
        break;
      case ESTRELAIGUAL:
        jj_consume_token(ESTRELAIGUAL);
                                         System.out.println("PONTUACAO: *=");
        break;
      case CONTRABARRAIGUAL:
        jj_consume_token(CONTRABARRAIGUAL);
                                     System.out.println("PONTUACAO: /=");
        break;
      case PORCENTOIGUAL:
        jj_consume_token(PORCENTOIGUAL);
                                         System.out.println("PONTUACAO: %=");
        break;
      case CHAPEUIGUAL:
        jj_consume_token(CHAPEUIGUAL);
                                         System.out.println("PONTUACAO: ^=");
        break;
      case ECOMERCIALIGUAL:
        jj_consume_token(ECOMERCIALIGUAL);
                                         System.out.println("PONTUACAO: &=");
        break;
      case OUIGUAL:
        jj_consume_token(OUIGUAL);
                                                 System.out.println("PONTUACAO: |=");
        break;
      case MENORMENORIGUAL:
        jj_consume_token(MENORMENORIGUAL);
                                         System.out.println("PONTUACAO: <<=");
        break;
      case MAIORMAIORIGUAL:
        jj_consume_token(MAIORMAIORIGUAL);
                                         System.out.println("PONTUACAO: >>=");
        break;
      case IGUAL:
        jj_consume_token(IGUAL);
                                                 System.out.println("IGUAL =");
        break;
      case IGUALIGUAL:
        jj_consume_token(IGUALIGUAL);
                                         System.out.println("PONTUACAO: ==");
        break;
      case DIFERENTE:
        jj_consume_token(DIFERENTE);
                                         System.out.println("PONTUACAO: !=");
        break;
      case MAIORQUE:
        jj_consume_token(MAIORQUE);
                                         System.out.println("PONTUACAO: >");
        break;
      case MENORQUE:
        jj_consume_token(MENORQUE);
                                         System.out.println("PONTUACAO: <");
        break;
      case MAIOROUIGUAL:
        jj_consume_token(MAIOROUIGUAL);
                                         System.out.println("PONTUACAO: >=");
        break;
      case MENOROUIGUAL:
        jj_consume_token(MENOROUIGUAL);
                                         System.out.println("PONTUACAO: <=");
        break;
      case ARROBA:
        jj_consume_token(ARROBA);
                                                 System.out.println("PONTUACAO: @");
        break;
      case UNDERLINE:
        jj_consume_token(UNDERLINE);
                                         System.out.println("PONTUACAO: _");
        break;
      case PONTO:
        jj_consume_token(PONTO);
                                                 System.out.println("PONTUACAO: .");
        break;
      case PONTOPONTO:
        jj_consume_token(PONTOPONTO);
                                         System.out.println("PONTUACAO: ..");
        break;
      case PONTOPONTOPONTO:
        jj_consume_token(PONTOPONTOPONTO);
                                         System.out.println("PONTUACAO: ...");
        break;
      case PONTOPONTOIGUAL:
        jj_consume_token(PONTOPONTOIGUAL);
                                         System.out.println("PONTUACAO: ..=");
        break;
      case VIRGULA:
        jj_consume_token(VIRGULA);
                                                 System.out.println("PONTUACAO: ,");
        break;
      case PONTOVIRGULA:
        jj_consume_token(PONTOVIRGULA);
                                         System.out.println("PONTUACAO: ;");
        break;
      case DOISPONTOS:
        jj_consume_token(DOISPONTOS);
                                         System.out.println("PONTUACAO: :");
        break;
      case DUPLODOISPONTOS:
        jj_consume_token(DUPLODOISPONTOS);
                                         System.out.println("PONTUACAO: ::");
        break;
      case SETA:
        jj_consume_token(SETA);
                                                 System.out.println("PONTUACAO: ->");
        break;
      case SETAGORDA:
        jj_consume_token(SETAGORDA);
                                         System.out.println("PONTUACAO: =>");
        break;
      case QUADRADO:
        jj_consume_token(QUADRADO);
                                         System.out.println("PONTUACAO: #");
        break;
      case CIFRAO:
        jj_consume_token(CIFRAO);
                                                 System.out.println("CIFRAO $");
        break;
      case ASPASDUPLAS:
        jj_consume_token(ASPASDUPLAS);
                                         System.out.println("PONTUACAO: \u005c"");
        break;
      case ASPASSIMPLES:
        jj_consume_token(ASPASSIMPLES);
                                         System.out.println("PONTUACAO: \u005c'");
        break;
      case INTERROGACAO:
        jj_consume_token(INTERROGACAO);
                                         System.out.println("PONTUACAO: ?");
        break;
      case ACHAVES:
        jj_consume_token(ACHAVES);
                                                 System.out.println("ACHAVES {");
        break;
      case FCHAVES:
        jj_consume_token(FCHAVES);
                                                 System.out.println("FCHAVES }");
        break;
      case APAREN:
        jj_consume_token(APAREN);
                                                 System.out.println("APAREN (");
        break;
      case FPAREN:
        jj_consume_token(FPAREN);
                                                 System.out.println("FPAREN )");
        break;
      case ACOLCHETE:
        jj_consume_token(ACOLCHETE);
                                                 System.out.println("ACOLCHETE [");
        break;
      case FCOLCHETE:
        jj_consume_token(FCOLCHETE);
                                                 System.out.println("FCOLCHETE ]");
        break;
      case BOOLEANO:
        jj_consume_token(BOOLEANO);
                                         System.out.println("BOLEANO: bool");
        break;
      case NUM:
        t = jj_consume_token(NUM);
                                                 System.out.println("NUM " + t.image);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
                                                 System.out.println("FLOAT " + t.image);
        break;
      case CADEIA:
        t = jj_consume_token(CADEIA);
                                     System.out.println("CADEIA " + t.image);
        break;
      case MACRO:
        t = jj_consume_token(MACRO);
                                     System.out.println("MACRO: " + t.image);
        break;
      case CARACTERE:
        t = jj_consume_token(CARACTERE);
                                     System.out.println("CARACTERE " + t.image);
        break;
      case ID:
        t = jj_consume_token(ID);
                         System.out.println("ID " + t.image);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public RustTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffffffe,0xfffffffe,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xffffffff,0xffffffff,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xfffffffb,0xfffffffb,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x7ffff,0x7ffff,};
   }

  /** Constructor with InputStream. */
  public Rust(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Rust(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new RustTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Rust(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new RustTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Rust(RustTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(RustTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[119];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 119; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
