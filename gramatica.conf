S' -> BLC_MAIN 
BLC_MAIN -> fn main ( PAR ) { CD } BLC
BLC -> fn ID ( PAR ) { CD } BLC
BLC -> ''
PAR -> ID : TIPO PR
PAR -> ''
PR -> ''
PR -> , PAR
TIPO -> int
TIPO -> i8
TIPO -> i16
TIPO -> i32
TIPO -> i64
TIPO -> i128
TIPO -> isize
TIPO -> u8
TIPO -> u16
TIPO -> u32
TIPO -> u64
TIPO -> u128
TIPO -> usize
TIPO -> f32
TIPO -> f64
TIPO -> ()
TIPO -> char
TIPO -> bool
CD -> INST
CD -> ''
INST -> INST_IF
INST -> INST_WL
INST -> INST_VAR
INST -> return EXP PV
INST -> EXP PV
INST -> CHAMA_FUNC
INST -> ACESSA_VET
ACESSA_VET -> ID [ NUM ] PV AV
AV -> ''
AV -> INST
PV -> ;
PV -> ''
CHAMA_FUNC -> ID ( EXP EP ) ; CF
CHAMA_FUNC -> EXP ID ( PAR ) ; CF
EP -> , EXP
EP -> ''
CF -> ''
CF -> INST
OP -> opc
OP -> opAum
OP -> opAdois
OP -> opL
INST_IF -> if EXP { CD } IN
INST_IF -> if ID ( EXP EP ) { CD } IN
IN -> else if ID ( EXP EP ) { CD } IN
IN -> else if EXP { CD } IN
IN -> else { CD } IN
IN -> ''
IN -> INST
INST_WL -> while ( EXP ) { CD } R
R -> ''
R -> INST
INST_VAR -> let ID ; IV
INST_VAR -> let ID = ID ; IV
INST_VAR -> let ID = NUM ; IV
INST_VAR -> let ID : = TIPO NUM ; IV
INST_VAR -> let ID : [ TIPO ; NUM ] = [ NUM , NUM ] ; IV
INST_VAR -> let ID : [ TIPO ; NUM ] = [ NUM MP ] ; IV
MP -> , NUM MP
MP -> ''
IV -> ''
IV -> INST
EXP -> EXP opC T
opC -> <
opC -> <=
opC -> >
opC -> >=
opC -> <>
opC -> >
opC -> !=
opC -> ==
EXP -> T
T -> T opAum Y
opAum -> +
opAum -> -
T -> Y
Y -> Y opAdois X
opAdois -> *
opAdois -> /
opAdois -> %
opAdois -> ^
Y -> X
X -> X opL J
opL -> ||
opL -> &&
X -> J
J -> ! F
J -> F
F -> ID
F -> VAR
F -> NUM
F -> ( EXP )